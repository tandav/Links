# Interactive systems 
## Round-Robin (Циклическое) 
- каждому процессу выделяется интервал времени (квант). Оптимальное значение 20-50 мс. 
	- переключение процесса, или переключение контекста требует время и тут типа нужно подобрать оптимальное дерьмо
- Если к концу кванта времени процесс все еще работает, он прерывается, а управ­ление передается другому процессу. 
- Когда процесс исчерпал свой лимит времени, он отправляется в конец списка .

## Priority Scheduling  
- каждому процессу присваивается приоритет и запускается тот процесс, который находится в состоянии готовности и имеет наивысший приоритет. 
- Чт обы избежать постоянного выполнения только приоритетных процессов, с каждым сигналом таймера (то есть с каждым прерыванием процесса). его приоритет снижается, и на первый план выходят процессы ниже приоритетами. 
- Можно выбрать и другую альтернативу: каждому процессу может быть выделен максимальный квант допусти- мого времени выполнения. Когда квант времени будет исчерпан, шанс запуска будет предоставлен другому процессу, имеющему наивысший приоритет.
- бывает удобно группировать процессы по классам приоритетности и использовать приоритетное планирование применительно к этим классам, а внутри каждого класса использовать циклическое планирование. 
- Приоритеты могут присваивает ся статически и динамически. [Not very important]
  	- https://cloud.githubusercontent.com/assets/5549677/25243126/a1fa1cfc-2604-11e7-89f1-64dd49b1b119.png

## Multiple Queues 
- используется описанная выше группировка процессов по классам приоритетов
- классы приоритетов. Процессы, относящиеся к наивысшему классу, запускались на 1 квант времени, процессы следующего по нисходящей класса — на 2 кванта времени, процессы следующего класса — на 4 кванта времени и т. д. Как только процесс использовал все выделенные ему кванты времени, его класс понижался. 
- сокращается число обмен данными с диском
- пример [UNIMPORTANT]
  	- В качестве примера рассмотрим процесс, который нужен для вычислений продол- жительностью в 100 квантов времени. Сначала ему будет выделен 1 квант времени, после чего он будет выгружен на диск. В следующий раз ему перед выгрузкой на диск будут выделены 2 кванта времени. При последующих запусках он будет получать 4, 8, 16, 32 и 64 кванта времени, хотя из финальных 64 квантов он для завершения своей работы использует лишь 37. Вместо 100 обменов данными с диском, которые потребо- вались бы при использовании циклического алгоритма, потребуется только 7 (включая начальную загрузку). Более того, по мере погружения процесса в очередь приоритетов он будет запускаться все реже и реже, сберегая время центрального процессора для коротких интерактивных процессов. 

## Shortest Process Next 
- estimates based on past behavior (past executions time)
- and run the process with the shortest estimated running time 

## Guaranteed Scheduling 
- let there are n processes
- каждому гарантируется 1/n процессорного времени 
- выбираются те процессы, у которых самое низкое соотношение использованного времени к тому на которое ему дали право

## Lottery Scheduling 
- Проводятся розыгрыши процессорного времени. Например 50 раз в секунду разыгрывают ся 20 мс процессорного времени.
- Все процессы равны, но некоторые равнее. Более важным процессам, чтобы повысить их шансы на выигрыш, могут выдаваться дополнительные билеты.

## Fair-Share Scheduling 
- уделяется внимание тому что каждый пользователь ОС, вне зависимости от того сколько он создал процессов получит 1/n процессорного времени
- Т. е. предотвращается ситуация, когда один user понасоздавал дохуя процессов и занял все процессорное время, потому что у других users по мелочи процессов.
